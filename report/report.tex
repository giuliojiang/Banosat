\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{smartdiagram}
\usepackage{titling}

\usepackage{xcolor}
\usepackage{hyperref}

\usepackage{color}
\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\definecolor{darkgray}{rgb}{0.4, 0.4, 0.4}
%\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{editorGray}{rgb}{0.95, 0.95, 0.95}
\definecolor{editorOcher}{rgb}{1, 0.5, 0} % #FF7F00 -> rgb(239, 169, 0)
\definecolor{editorGreen}{rgb}{0, 0.5, 0} % #007C00 -> rgb(0, 124, 0)
\definecolor{orange}{rgb}{1,0.45,0.13}		
\definecolor{olive}{rgb}{0.17,0.59,0.20}
\definecolor{brown}{rgb}{0.69,0.31,0.31}
\definecolor{purple}{rgb}{0.38,0.18,0.81}
\definecolor{lightblue}{rgb}{0.1,0.57,0.7}
\definecolor{lightred}{rgb}{1,0.4,0.5}
\usepackage{upquote}
\usepackage{listings}
% CSS
\lstdefinelanguage{CSS}{
  keywords={color,background-image:,margin,padding,font,weight,display,position,top,left,right,bottom,list,style,border,size,white,space,min,width, transition:, transform:, transition-property, transition-duration, transition-timing-function},	
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  alsoletter={:},
  alsodigit={-}
}

% JavaScript
\lstdefinelanguage{JavaScript}{
  morekeywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  morestring=[b]",
  morestring=[b]'
}

\lstdefinelanguage{HTML5}{
  language=html,
  sensitive=true,	
  alsoletter={<>=-},	
  morecomment=[s]{<!-}{-->},
  tag=[s],
  otherkeywords={
  % General
  >,
  % Standard tags
	<!DOCTYPE,
  </html, <html, <head, <title, </title, <style, </style, <link, </head, <meta, />,
	% body
	</body, <body,
	% Divs
	</div, <div, </div>, 
	% Paragraphs
	</p, <p, </p>,
	% scripts
	</script, <script,
  % More tags...
  <canvas, /canvas>, <svg, <rect, <animateTransform, </rect>, </svg>, <video, <source, <iframe, </iframe>, </video>, <image, </image>, <header, </header, <article, </article
  },
  ndkeywords={
  % General
  =,
  % HTML attributes
  charset=, src=, id=, width=, height=, style=, type=, rel=, href=,
  % SVG attributes
  fill=, attributeName=, begin=, dur=, from=, to=, poster=, controls=, x=, y=, repeatCount=, xlink:href=,
  % properties
  margin:, padding:, background-image:, border:, top:, left:, position:, width:, height:, margin-top:, margin-bottom:, font-size:, line-height:,
	% CSS3 properties
  transform:, -moz-transform:, -webkit-transform:,
  animation:, -webkit-animation:,
  transition:,  transition-duration:, transition-property:, transition-timing-function:,
  }
}

\lstdefinestyle{htmlcssjs} {%
  % General design
%  backgroundcolor=\color{editorGray},
  basicstyle={\footnotesize\ttfamily},   
  frame=b,
  % line-numbers
  xleftmargin={0.75cm},
  numbers=left,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,	
  % Code design
  identifierstyle=\color{black},
  keywordstyle=\color{blue}\bfseries,
  ndkeywordstyle=\color{editorGreen}\bfseries,
  stringstyle=\color{editorOcher}\ttfamily,
  commentstyle=\color{brown}\ttfamily,
  % Code
  language=HTML5,
  alsolanguage=JavaScript,
  alsodigit={.:;},	
  tabsize=2,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
  % German umlauts
  literate=%
  {Ö}{{\"O}}1
  {Ä}{{\"A}}1
  {Ü}{{\"U}}1
  {ß}{{\ss}}1
  {ü}{{\"u}}1
  {ä}{{\"a}}1
  {ö}{{\"o}}1
}
%
\lstdefinestyle{py} {%
language=python,
literate=%
*{0}{{{\color{lightred}0}}}1
{1}{{{\color{lightred}1}}}1
{2}{{{\color{lightred}2}}}1
{3}{{{\color{lightred}3}}}1
{4}{{{\color{lightred}4}}}1
{5}{{{\color{lightred}5}}}1
{6}{{{\color{lightred}6}}}1
{7}{{{\color{lightred}7}}}1
{8}{{{\color{lightred}8}}}1
{9}{{{\color{lightred}9}}}1,
basicstyle=\footnotesize\ttfamily, % Standardschrift
numbers=left,               % Ort der Zeilennummern
%numberstyle=\tiny,          % Stil der Zeilennummern
%stepnumber=2,               % Abstand zwischen den Zeilennummern
numbersep=5pt,              % Abstand der Nummern zum Text
tabsize=4,                  % Groesse von Tabs
extendedchars=true,         %
breaklines=true,            % Zeilen werden Umgebrochen
keywordstyle=\color{blue}\bfseries,
frame=b,
commentstyle=\color{brown}\itshape,
stringstyle=\color{editorOcher}\ttfamily, % Farbe der String
showspaces=false,           % Leerzeichen anzeigen ?
showtabs=false,             % Tabs anzeigen ?
xleftmargin=17pt,
framexleftmargin=17pt,
framexrightmargin=5pt,
framexbottommargin=4pt,
%backgroundcolor=\color{lightgray},
showstringspaces=false,      % Leerzeichen in Strings anzeigen ?
}%

\setlength{\parindent}{0pt}

\begin{document}


\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        \vspace*{1cm}          
        \vspace{0.5cm}
        \LARGE
        Software Reliability\\ SAT Solver\\
                \noindent\rule{8cm}{0.4pt}
        \vspace{1.5cm}
 
        \large
        \textbf{Abra\~{a}o Pacheco Dos Santos Peres Mota} - CID: 00941232 \\
        \textbf{Giulio Jiang} - CID: 00979137 \\
        \textbf{Domenico Marino} - CID: 00979083 \\

        \vfill
        \vspace{0.8cm}
        \Large
        Department of Computing\\
        Imperial College London\\
        \today
        
    \end{center}
\end{titlepage}


\newpage

\section{Algorithm}

We propose our implementation of a simple yet functional SAT solver, entirely written in C. The program is completely self-contained and does not depend on any external library other than the standard \texttt{libc}.\\
Our solver is based on the DPLL algorithm, on top of which we have implemented a few optimizations. DPLL has been chosen for being intuitive in its workings, and for its expandability to include additional features and optimizations.\\
The solver accepts standard DIMACS CNF file formats, and will print UNSAT, or SAT accompanied by a model.\\
It is interesting to point out that our solver is completely deterministic, as it does not rely on any random number generator.\\

\subsection{Overview of execution}

We implement a standard DPLL loop. At each iteration, we pick a variable and assign an arbitrary value to it. Afterwards, we run BCP and PLP, evaluate the formula, and continue with assignments or backtrack depending on the result.\\

\subsection{BCP}

We implement BCP as a unit resolution algorithm. Given the formula, the BCP loop automatically assigns a value to all unit clauses found until there is no unit clause left in the formula, or a contradiction is derived.\\
The algorithm scans through the current working set for variables that have no assignment, to find the clauses that have exactly one unassigned variable. This means that our BCP algorithm will also work on clauses that have more than one variable present, although by construction of our unsatisfied clauses this isn't the case.\\
Automatic assignments generated by BCP are recorded in the assignments history table in a distinct section from the arbitrary assignments, as they are treated differently when backtracking.\\

\subsection{PLP}

PLP acts as an optimisation for our solver in order to more quickly determine assignments for a subset of variables in our formula which appear as \textit{pure literals}. A pure literal may appear in several clauses in the formula, but all the occurrences of this literal are either in its normal, positive form (e.g \texttt{p}), or they occur in the negated form of the literal (i.e. $\neg$\texttt{p}). Whenever a pure literal is detected, then we can immediately determine its assignment in the formula to satisfy it - if we have a pure positive literal, setting it to \texttt{true} is the only way to satisfy all these occurrences. On the other hand, for pure negated literals, these are set to \texttt{false}. \\

We implemented this by adding two different counters to our variable struct, one counting the occurrences of a positive literal in all the current clauses, while the other counter was for the occurrences of a negated literal. For a variable to occur as a pure positive literal, the matching counter should be greater than 0 and the negated literal counter at 0. The opposite is true for pure negated literals. This implementation needed to track changes to the working set of clauses, so whenever a clause was added or removed from our list of unsatisfied clauses, we looped over all the literals within it and updated the variable state counters accordingly. Doing this state management on assignment allowed us to discern pure variables very quickly, at the small overhead cost of managing this state.

\subsection{Backtracker}

The main loop of the solver does not use recursion, therefore we cannot use the call stack to keep track of the state to which we revert to in case we derive a contradiction. Additionally, we do not create copies of the formula, the variables and the clauses, but also work on the data in-place, which makes direct recursion impractical.\\
For the above reasons, we implemented a backtracker based on a heap-allocated assignment history tracker, which provides the full history of decisions, and a variable assignment map, which represents the current assignments to all variables.\\
The joint action of the decision algorithm and the backtracker create a depth-first search behaviour of the assignments space in the order that is initially generated for the variable. See the optimizations on variable decision section for the initial order of the variables.\\
The backtracker uses information contained in the assignment history levels to undo actions performed by both BCP and PLP and prepare the working context for the next assignment by un-assigning all temporary values from the variables. This approach allows us to work on a single copy of clauses and variables when exploring unknown branches.\\

\subsection{Data structures and design}

We have implemented the following data structures:

\begin{itemize}

\item \texttt{arraylist} - A simple heap-allocated array list, used for long-term storage of items that are read frequently but rarely modified

\item \texttt{linkedlist} - A doubly-linked list, used for data that is frequently inserted or deleted at arbitrary positions in the list

\item \texttt{arraymap} - An integer-key map specifically designed for the variables assignment map, optimized for fast element access

\item \texttt{hashset} - A generic hash set implementation, used to check for duplicate items

\end{itemize}

\section{Optimizations}

In an attempt to increase the efficiency of our solver, we have implemented the following optimizations.

\subsection{Constant time formula evaluation}

We have designed our solver to work around the formula with 2 auxiliary data structures -  \texttt{false\_clauses} is a linked list of the working set of clauses we currently evaluate to be \texttt{false}, and \texttt{unsat} is a linked list of the clauses that are currently unsatisfied. These 2 structures allow us to focus on working with only the currently important clauses in question, and make it easy for us to evaluate the current state of the formula. Specifically, we know that the formula is false simply by checking the size of our \texttt{false\_clauses} list to be greater than 0. Passing that check, if there are no clauses in the \texttt{unsat} list, we know it is true, otherwise, the entire formula is still unsatisfiable. These 2 data structures allow us to evaluate the overall formula in constant time by querying their size, at the slight cost of keeping them updated as we assign and revert variable mappings.

\subsection{Clause literals optimization}
We have further optimized clauses at the parsing level - we have ignored literals within a clause that occur more than once (in their specific literal form). In some test cases this behaviour was tested, and raised some bugs in our implementation. A literal occurring more than once in a formula can be ignored at the parse level as it does not add further information to the clause. Additionally, we have also looked out for literals occurring with their negated counterparts in the same clause (for example, a clause of \texttt{p $\vee$ $\neg$ p}). These clauses become trivially true by logical evaluation, so we discard them from our formula altogether.


\subsection{Variable decision heuristics}

Our initial variable decision algorithm was very simple, as it involved selecting the first unassigned variable, ordered by the appearance order in the \texttt{CNF}, this was very simple to implement, but started showing its limits very early, for example with one hundred variables, the execution time was already in the order of minutes. \\
To improve our decision logic, we decided to adopt an heuristic that takes inspiration from \emph{Dynamic Largest Individual Sum (DLIS)} heuristic, but simplified;
\emph{DLIS} selects the variable that satisfies the highest number of clauses, a potential drawback of \emph{DLIS} is that the variables have to be sorted after each decision point, and this could potentially be expensive from a performance point of view. \\
Our approach instead selects the unsatisfied variable that appears in the most clauses, and sorts the variables only once, at the beginning of the evaluation, this is done to ensure good performance, moreover, it is simple to implement and easy to debug.
As a smaller optimisation, our algorithm remembers what was the last assigned variable and starts searching for the closest unassigned one from there, this is done to speed up the decision for huge numbers of variables. \\
Using a wide variety of diverse \texttt{CNFs} we managed to obtain an average speed-up of 7x to 10x, for some test cases instead this resulted in unquantifiable speed-up, as one of our test \texttt{CNFs} (225 variables, dozens of thousands clauses) timed out after 1 hour with the initial approach, and completed in 16 minutes with the refined one.

\subsection{Conflicts database}

When taking decisions we keep track of the dependency graph between assignment. At a clause that evaluates to false, we can therefore follow the graph to find the root nodes containing the primary assignments, and generate a conflict clause that will be added to the conflicts database and evaluated together with the rest of the formula.\\
The conflict database has a fixed maximum size, which is necessary because of the complexity of our algorithm as the number of clauses increases. It is stored in a queue, and older conflict clauses are removed when the maximum size is reached.

\subsection{Reverse BCP}

We traverse known clauses in reverse order. In this way the newest conflict clauses are analyzed first, allowing us to derive falsity faster in the average case.

\subsection{Unit clause watch}

To increase the effectiveness of BCP, we keep track of all the unsatisfied clauses with a single unassigned literal in a separate list. BCP does not need therefore to iterate through all unsatisfied lists and find those that only contain a single unassigned literal.\\
This optimization yields large speed improvements in general as it reduces the underlying complexity of our BCP algorithm.

\section{Difficulties and testing}

One of the custom tests we used highlighted an edge case our solver wasn't handling correctly - using duplicated literals in a single clause. In any logical clause, having a duplicated literal adds no semantic value, so these can be ignored. However, our parser wasn't explicitly ignoring literals that were already added to our \texttt{variable\_map} structure. As adding literals updated other state across our solver, this meant we added 2 duplicate clauses to our \texttt{unsat} clause list. This meant when we removed that clause from the list, there would still be the duplicate left in the list. This lead to the solver prematurely deciding that a formula was unsatisfiable due to the extra unsatisfied clause. \\

The test formulae provided are useful for the parsing and initial testing, but are definitely not useful to assess the performance of the solver, this is due to the fact that performance for small number of variables or clauses is already very low without any heuristic or optimisation. \\
To assess our performance we relied on formulae from \texttt{SATLIB}\footnote{http://www.cs.ubc.ca/~hoos/SATLIB/benchm.html}, the website provides various sets of randomly generated formulae ranging from medium to large.
These formulae, plus the ones from \texttt{SATCOMP} resulted in a comprehensive set of queries to check for correctness and efficiency. \\
Joining these formulae, we have a script that executes \texttt{MiniSat 2}\footnote{http://minisat.se/MiniSat.html} on each formula and stores the result for a comparison with our solver.
This script allowed us to trace a bug related to \texttt{PLP} resulting in the execution terminating early and reporting the formula to be \texttt{UNSAT}; This bug only appeared with reasonably large formulae, which made the bug hard to spot by us. \\
Furthermore we did not implement Watch Literals in time, making our BCP algorithm quadratic in complexity as the number of clauses grows. Given enough time, we would implement Watch Literals as the next feature.\\


\section{The Undefined Behaviour Bug}

Our undefined behaviour bug patch introduces a use-after-free in some circumstances during backtracking.\\
As described in our optimizations section, we use two trackers to remember lists of clauses that are currently unsatisfied and currently false. At each assignment and un-assignment, we update the lists.\\
It would be a plausible bug to free the element being removed from one of those lists while removing the linkedlist's node. We introduce the bug by freeing a clause when removing it from the list of false clauses. However, our clause objects are shared among other data structures as well, so they might be reused after this free.\\
The bug doesn't always manifest itself when running the solver normally. In fact tests 2, 3 and 4 run correctly despite the bug, while test 1 crashes with a segmentation fault. These behaviours could be different using different compilers or operating systems.\\
Clang's address sanitizer is able to correctly identify the use-after-free.

\section{The Functional Bug}


\textbf{PLP current assignment ignore} \\

For our functional bug, we have chosen to look at the case where in PLP we willfully ignore whether the current variable has been assigned to already or not. Because our implementation of PLP iterates over all the variables in our formula looking for pure literals, if one of these variables is a pure literal and has a pre-existing assignment, then PLP will attempt to overwrite its value. This is a subtle bug as it only expresses itself when the previous assignment is contradictory to the value a pure literal should logically be in the existing unsat clauses - i.e. a purely negated literal \textit{should} be assigned to false in the formula to satisfy it (as PLP attempts to do with our current set of unsat clauses). However, if the existing assignment to this variable is true, then PLP will ignore this and attempt PLP using a negated assignment. This bug doesn't cause an infinite loop due to how we are keeping our assignment history. Further assignments made down the line by PLP have as a parent assignment the original assignment that the variable had, even though it isn't being taken into consideration. These PLP assignments will inevitably cause an unsat formula on the parent assignment because they are ignoring the assignment history. \\

A concise example of when this happens can be found in the original \texttt{test4.cnf} file provided (a copy has been made in \texttt{funcerr.cnf}). When the first variable is decided to be \texttt{true} by our algorithm, the leftover unsat clause contains a negated literal of the first variable, and because it is our only unsat clause, this is an occurrence of a pure literal. This then instantly triggers the bug as PLP assigns that variable to \texttt{false}.

\end{document}